# Chapter 4: Factory Patterns - Key Learnings (Generated by AI)

## Pattern Overview

This chapter covers **three variations** of factory patterns, each solving different object creation problems:

1. **Simple Factory** - Not a design pattern, but a programming idiom
2. **Factory Method** - Defers object creation to subclasses
3. **Abstract Factory** - Creates families of related objects

## Design Principle

**Dependency Inversion Principle**: Depend upon abstractions. Do not depend upon concrete classes.

### Guidelines for Dependency Inversion
- No variable should hold a reference to a concrete class
- No class should derive from a concrete class
- No method should override an implemented method of its base class

> [!NOTE]
> These are *guidelines*, not absolute rules. Strive to follow them, but pragmatism is important!

---

## 1. Simple Factory

### Problem
You have conditional logic scattered throughout your code to create different types of objects.

### Solution
Encapsulate object creation in a single class with a factory method.

### Implementation

```java
public class SimplePizzaFactory {
    public Pizza createPizza(PizzaType type) {
        return switch (type) {
            case CHEESE -> new CheesePizza();
            case PEPPERONI -> new PepperoniPizza();
            case CLAM -> new ClamPizza();
            case VEGGIE -> new VeggiePizza();
            default -> throw new IllegalArgumentException("Invalid pizza type");
        };
    }
}
```

### Usage

```java
SimplePizzaFactory factory = new SimplePizzaFactory();
Pizza pizza = factory.createPizza(PizzaType.CHEESE);
```

### Pros and Cons

✅ **Advantages:**
- Centralizes object creation logic
- Easy to maintain (one place to change)
- Reduces code duplication

❌ **Limitations:**
- Not a true design pattern
- Not extensible without modifying the factory
- Violates Open-Closed Principle (not open for extension)

---

## 2. Factory Method Pattern

### Pattern Definition

**Factory Method Pattern**: Defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.

### Problem
You need different variations of products, but the creation logic is too complex or region-specific to be centralized in one simple factory.

### Solution
Define an abstract method (factory method) in a base class and let subclasses implement it to create region-specific products.

### Structure

```
Creator (abstract)
├── factoryMethod() - abstract
└── operation() - uses factoryMethod()

ConcreteCreatorA extends Creator
└── factoryMethod() - returns ConcreteProductA

ConcreteCreatorB extends Creator
└── factoryMethod() - returns ConcreteProductB
```

### Implementation: Pizza Store Example

**Abstract Creator:**
```java
public abstract class PizzaStoreBase {
    // Template method - same for all stores
    public Pizza orderPizza(PizzaType type) {
        Pizza pizza = createPizza(type);  // Factory method
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    
    // Factory method - subclasses implement this
    protected abstract Pizza createPizza(PizzaType type);
}
```

**Concrete Creators:**
```java
public class NYPizzaStore extends PizzaStoreBase {
    @Override
    protected Pizza createPizza(PizzaType type) {
        return switch (type) {
            case CHEESE -> new NYStyleCheesePizza();
            case PEPPERONI -> new NYStylePepperoniPizza();
            case CLAM -> new NYStyleClamPizza();
            case VEGGIE -> new NYStyleVeggiePizza();
        };
    }
}

public class ChicagoPizzaStore extends PizzaStoreBase {
    @Override
    protected Pizza createPizza(PizzaType type) {
        return switch (type) {
            case CHEESE -> new ChicagoStyleCheesePizza();
            // ... other Chicago-style pizzas
        };
    }
}
```

### Usage

```java
PizzaStoreBase nyStore = new NYPizzaStore();
Pizza pizza = nyStore.orderPizza(PizzaType.CHEESE);  // Gets NY-style cheese pizza

PizzaStoreBase chicagoStore = new ChicagoPizzaStore();
Pizza pizza2 = chicagoStore.orderPizza(PizzaType.CHEESE);  // Gets Chicago-style cheese pizza
```

### Key Characteristics

1. **Parallel Class Hierarchies**: Product classes (pizzas) parallel the Creator classes (stores)
2. **Template Method + Factory Method**: `orderPizza()` is a template method that uses the factory method
3. **Open-Closed Principle**: Can add new stores without modifying existing code
4. **Single Responsibility**: Each store knows only about its regional pizzas

### Pros and Cons

✅ **Advantages:**
- Extensible (add new product types via new subclasses)
- Follows Open-Closed Principle
- Decouples client code from concrete product classes
- Encapsulates product creation logic

❌ **Limitations:**
- Requires creating a new subclass for each variation
- Can lead to many classes (class explosion)
- Doesn't handle creation of *families* of related objects

---

## 3. Abstract Factory Pattern

### Pattern Definition

**Abstract Factory Pattern**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

### Problem
You need to create families of related objects that must be used together, and you want to ensure compatibility between them.

**Example**: NY pizzas need NY-style ingredients (thin crust, marinara, reggiano cheese, fresh clams), while Chicago pizzas need Chicago-style ingredients (thick crust, plum tomato sauce, mozzarella, frozen clams).

### Solution
Create an abstract factory interface that declares methods for creating each type of related object. Concrete factories implement this interface to create region-specific product families.

### Structure

```
AbstractFactory (interface)
├── createProductA()
├── createProductB()
└── createProductC()

ConcreteFactory1 implements AbstractFactory
├── createProductA() -> ProductA1
├── createProductB() -> ProductB1
└── createProductC() -> ProductC1

ConcreteFactory2 implements AbstractFactory
├── createProductA() -> ProductA2
├── createProductB() -> ProductB2
└── createProductC() -> ProductC2
```

### Implementation: Pizza Ingredient Factory

**Abstract Factory:**
```java
public interface PizzaIngredientFactory {
    Dough createDough();
    Sauce createSauce();
    Cheese createCheese();
    Clams createClams();
}
```

**Concrete Factories:**
```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
    public Dough createDough() { return new ThinCrustDough(); }
    public Sauce createSauce() { return new MarinaraSauce(); }
    public Cheese createCheese() { return new ReggianoCheese(); }
    public Clams createClams() { return new FreshClams(); }
}

public class ChicagoPizzaIngredientFactory implements PizzaIngredientFactory {
    public Dough createDough() { return new ThickCrustDough(); }
    public Sauce createSauce() { return new PlumTomatoSauce(); }
    public Cheese createCheese() { return new MozzarellaCheese(); }
    public Clams createClams() { return new FrozenClams(); }
}
```

**Product Using Factory:**
```java
public class CheesePizza extends Pizza {
    private PizzaIngredientFactory ingredientFactory;
    
    public CheesePizza(PizzaIngredientFactory ingredientFactory) {
        this.ingredientFactory = ingredientFactory;
    }
    
    @Override
    public void prepare() {
        this.name = "Cheese Pizza";
        this.dough = ingredientFactory.createDough();
        this.sauce = ingredientFactory.createSauce();
        this.cheese = ingredientFactory.createCheese();
        super.prepare();
    }
}
```

**Usage:**
```java
PizzaIngredientFactory nyFactory = new NYPizzaIngredientFactory();
Pizza nyCheesePizza = new CheesePizza(nyFactory);
nyCheesePizza.prepare();  // Uses NY-style ingredients

PizzaIngredientFactory chicagoFactory = new ChicagoPizzaIngredientFactory();
Pizza chicagoCheesePizza = new CheesePizza(chicagoFactory);
chicagoCheesePizza.prepare();  // Uses Chicago-style ingredients
```

### Key Characteristics

1. **Product Families**: Creates families of related objects
2. **Consistency**: Ensures that products from the same family are used together
3. **Isolation**: Client code is isolated from concrete product classes
4. **Composition over Inheritance**: Uses composition to inject the factory

### Pros and Cons

✅ **Advantages:**
- Ensures compatibility between related objects
- Isolates concrete classes from client
- Easy to exchange product families
- Promotes consistency among products

❌ **Limitations:**
- Supporting new kinds of products requires changing the abstract factory interface (and all concrete factories)
- Can be overkill for simple scenarios

---

## Factory Method vs. Abstract Factory

| Aspect | Factory Method | Abstract Factory |
|--------|----------------|------------------|
| **Purpose** | Create one product | Create families of related products |
| **Implementation** | Inheritance (subclasses) | Composition (factory injected) |
| **Focus** | Which concrete class to instantiate | Which family of products to use |
| **Extensibility** | Add new product types via new subclasses | Add new families via new factory classes |
| **Coupling** | Creator coupled to products | Client decoupled from products |
| **Complexity** | Simpler | More complex |
| **Example** | NYPizzaStore creates NY pizzas | NYIngredientFactory creates NY ingredients |

### Can They Be Combined?

**Yes!** In our implementation:
- **Factory Method** decides *which pizza* to create (NY vs Chicago)
- **Abstract Factory** decides *which ingredients* to use in that pizza

```java
public class NYPizzaStoreWithFactory extends PizzaStoreBase {
    @Override
    protected Pizza createPizza(PizzaType type) {
        PizzaIngredientFactory factory = new NYPizzaIngredientFactory();
        
        return switch (type) {
            case CHEESE -> new CheesePizza(factory);
            case PEPPERONI -> new PepperoniPizza(factory);
            // Factory Method + Abstract Factory working together!
        };
    }
}
```

---

## When to Use Which Factory?

### Use Simple Factory When:
- You have simple object creation logic
- Creation logic is unlikely to change frequently
- You don't need extensibility

### Use Factory Method When:
- You need to delegate object creation to subclasses
- You have parallel class hierarchies
- You want to follow Open-Closed Principle for adding new product types
- Creation logic varies by context/region

### Use Abstract Factory When:
- You need to create families of related objects
- You want to constrain which products can be used together
- You need to configure a system with multiple product families
- You want to hide concrete product classes from client code

---

## Real-World Examples

### Factory Method
- **Java Collections**: `iterator()` method is a factory method
  - Different collection types return different iterator implementations
  - `ArrayList.iterator()` vs `HashSet.iterator()`

### Abstract Factory
- **UI Frameworks**: Different look-and-feel factories create compatible UI components
  - WindowsFactory creates WindowsButton, WindowsCheckbox
  - MacFactory creates MacButton, MacCheckbox
- **Database Access**: Different database factories create compatible connection, statement, and result set objects

---

## Java-Specific Learnings

### 1. Modern Switch Expressions
Used Java 17's switch expressions with arrow syntax:
```java
return switch (type) {
    case CHEESE -> new CheesePizza();
    case PEPPERONI -> new PepperoniPizza();
    default -> throw new IllegalArgumentException("Invalid type");
};
```

**Benefits:**
- More concise than traditional switch
- Eliminates fall-through bugs
- Can be used as an expression (returns a value)
- Exhaustiveness checking with enums

### 2. Custom Exceptions
Created domain-specific exceptions:
- `InvalidPizzaTypeException` - for invalid pizza types
- `PizzaCreationException` - for general creation failures

**Why:** Better than generic exceptions, provides clearer error semantics

### 3. Interface vs Abstract Class for Factories
- **Abstract Factory** → Interface (`PizzaIngredientFactory`)
  - No state needed, just method contracts
  - Allows multiple inheritance (if needed)
- **Factory Method** → Abstract class (`PizzaStoreBase`)
  - Contains template method implementation
  - Provides default behavior

---

## Design Patterns Interaction

### Factory + Template Method
The Factory Method pattern naturally incorporates the Template Method pattern:
```java
public abstract class PizzaStoreBase {
    // Template method
    public Pizza orderPizza(PizzaType type) {
        Pizza pizza = createPizza(type);  // Calls factory method
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    
    // Factory method (the "hook")
    protected abstract Pizza createPizza(PizzaType type);
}
```

### Factory + Dependency Injection
Abstract Factory is essentially a form of dependency injection:
```java
public class CheesePizza extends Pizza {
    private PizzaIngredientFactory factory;
    
    // Factory injected via constructor
    public CheesePizza(PizzaIngredientFactory factory) {
        this.factory = factory;
    }
}
```

---

## Common Pitfalls

### 1. Over-Engineering
❌ **Don't** use factories for simple object creation
```java
// Overkill for simple cases
AnimalFactory factory = new AnimalFactory();
Dog dog = factory.createDog();
```

✅ **Do** use constructors for simple cases
```java
Dog dog = new Dog();
```

### 2. Forgetting Dependency Inversion
❌ **Don't** depend on concrete classes in factory method
```java
public Pizza orderPizza() {
    NYStyleCheesePizza pizza = createPizza();  // Coupled to concrete class
}
```

✅ **Do** depend on abstractions
```java
public Pizza orderPizza() {
    Pizza pizza = createPizza();  // Depends on abstraction
}
```

### 3. Mixing Responsibilities
❌ **Don't** put business logic in factories
```java
public class PizzaFactory {
    public Pizza createPizza(PizzaType type) {
        Pizza pizza = // ... create pizza
        pizza.bake();  // Factory shouldn't do this!
        return pizza;
    }
}
```

✅ **Do** keep factories focused on creation
```java
public class PizzaFactory {
    public Pizza createPizza(PizzaType type) {
        return new CheesePizza();  // Only creation
    }
}
```

---

## Testing Considerations

### Factory Method Testing
```java
@Test
public void testNYStoreCreatesNYPizza() {
    PizzaStoreBase store = new NYPizzaStore();
    Pizza pizza = store.orderPizza(PizzaType.CHEESE);
    
    assertTrue(pizza instanceof NYStyleCheesePizza);
}
```

### Abstract Factory Testing
```java
@Test
public void testNYFactoryCreatesNYIngredients() {
    PizzaIngredientFactory factory = new NYPizzaIngredientFactory();
    
    assertTrue(factory.createDough() instanceof ThinCrustDough);
    assertTrue(factory.createCheese() instanceof ReggianoCheese);
}
```

### Testing Tip
Consider using **mock factories** for testing:
```java
// Inject a test factory that creates predictable test ingredients
PizzaIngredientFactory testFactory = new TestPizzaIngredientFactory();
Pizza pizza = new CheesePizza(testFactory);
```

---

## Summary

### Key Takeaways

1. **Simple Factory**: Encapsulates object creation, but isn't extensible
2. **Factory Method**: Uses inheritance to delegate object creation to subclasses
3. **Abstract Factory**: Uses composition to create families of related objects

### Dependency Inversion Principle
All factory patterns help you follow the Dependency Inversion Principle by:
- Programming to interfaces, not implementations
- Reducing coupling to concrete classes
- Making code more maintainable and extensible

### Pattern Synergy
Factories often work together:
- Factory Method provides the framework for object creation
- Abstract Factory provides the products
- Template Method orchestrates the creation process

---

## Files Created

### Simple Factory
- [SimplePizzaFactory.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/simplefactory/SimplePizzaFactory.java) - Factory class
- [PizzaStore.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/simplefactory/PizzaStore.java) - Client using factory
- [CheesePizza.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/simplefactory/CheesePizza.java), PepperoniPizza.java, etc. - Products

### Factory Method
- [PizzaStoreBase.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/factorymethod/PizzaStoreBase.java) - Abstract creator
- [NYPizzaStore.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/factorymethod/NYPizzaStore.java), ChicagoPizzaStore.java - Concrete creators
- NYStyleCheesePizza.java, ChicagoStyleCheesePizza.java, etc. - Concrete products

### Abstract Factory
- [PizzaIngredientFactory.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/abstractfactory/PizzaIngredientFactory.java) - Abstract factory interface
- [NYPizzaIngredientFactory.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/abstractfactory/NYPizzaIngredientFactory.java), ChicagoPizzaIngredientFactory.java - Concrete factories
- [CheesePizza.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/abstractfactory/CheesePizza.java) - Pizza using ingredient factory

### Supporting Classes
- [Pizza.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/model/Pizza.java) - Abstract product
- [PizzaType.java](file:///c:/Users/Nikhil/AntigravityWorkspace/HeadFirstDesignPattern/src/main/java/com/headfirst/ch4/pizzastore/model/PizzaType.java) - Enum for pizza types
- Ingredient interfaces and implementations (Dough, Sauce, Cheese, Clams)
- Custom exceptions

---

## Next Steps

Continue to **Chapter 5: Singleton Pattern** (one instance to rule them all!)
